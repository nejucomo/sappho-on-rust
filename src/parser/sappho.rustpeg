use super::super::ast::{
    Expression,
    Function,
    FuncRule,
    Literal,
    Object,
    Pattern
};


#[pub]
expression -> Expression
  = i:identifier { Expression::Dereference(i) }
  / l:literal    { Expression::Literal(l)     }
  / o:object     { Expression::Object(o)      }

identifier -> String
  = ! "true"
    ! "false"
    ! "object"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }

object -> Object
  = "object" [ ]+ "{" [\n ]* f:func? [\n ]* "}"
    {
      Object::from_func(f.unwrap_or_else(|| Function::empty()))
    }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rules [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rules -> Vec<FuncRule>
  = rs:func_rule ** semisep
    { rs }

func_rule -> FuncRule
  = p:pattern [ ]+ "->" [\n ]* b:expression
    { FuncRule { pattern: p, body: b } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

semisep -> ()
  = ";" [\n ]*
    { () }
