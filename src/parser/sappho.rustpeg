use super::super::ast::{
    Expression,
    FuncRule,
    Function,
    Identifier,
    List,
    Literal,
    Object,
    Pattern,
    Proc,
    ProcExpression,
    Properties,
    PureLeafExpression,
    Query,
    QueryExpression,
    StatementBlock
};


#[pub]
expression -> Expression
  = ple:pureleafexpression { Expression::PLE(ple) }
  / le:list_expression     { Expression::LE(le)   }

queryexpression -> QueryExpression
  = ple:pureleafexpression   { QueryExpression::PLE(ple)     }
  / lqe:list_queryexpression { QueryExpression::LE(lqe)      }
  / qa:queryqueryapp         { QueryExpression::QueryApp(qa) }

procexpression -> ProcExpression
  = ple:pureleafexpression  { ProcExpression::PLE(ple)     }
  / lpe:list_procexpression { ProcExpression::LE(lpe)      }
  / qa:procqueryapp         { ProcExpression::QueryApp(qa) }
  / pa:procapp              { ProcExpression::ProcApp(pa)  }


pureleafexpression -> PureLeafExpression
  = i:identifier { PureLeafExpression::Dereference(i) }
  / l:literal    { PureLeafExpression::Literal(l)     }
  / o:object     { PureLeafExpression::Object(o)      }

identifier -> String
  = ! "false"
    ! "func"
    ! "object"
    ! "proc"
    ! "prop"
    ! "query"
    ! "return"
    ! "true"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }


object -> Object
  = "object" [ ]+ "{" [\n ]* tup:object_at_proc
    {
      let (p, q, f, props) = tup;
      Object { proc_: p, query: q, func: f, props: props }
    }
  / p:proc
    { Object::from_proc(p) }
  / q:query
    { Object::from_query(q) }
  / f:func
    { Object::from_func(f) }

object_at_proc -> (Option<Proc>, Option<Query>, Function, Properties)
  = p:proc [\n ]* tup:object_after_proc
    {
      let (q, f, props) = tup;
      (Some(p), q, f, props)
    }
  / tup:object_at_query
    {
      let (q, f, props) = tup;
      (None, q, f, props)
    }

object_after_proc -> (Option<Query>, Function, Properties)
  = semisep tup:object_at_query
    { tup }
  / "}"
    { (None, Function::empty(), Properties::empty()) }

object_at_query -> (Option<Query>, Function, Properties)
  = q:query [\n ]* tup:object_after_query
    {
      let (f, p) = tup;
      (Some(q), f, p)
    }
  / tup:object_at_func
    {
      let (f, p) = tup;
      (None, f, p)
    }

object_after_query -> (Function, Properties)
  = semisep tup:object_at_func
    { tup }
  / "}"
    { (Function::empty(), Properties::empty()) }

object_at_func -> (Function, Properties)
  = f:func [\n ]* props:object_after_func
    { (f, props) }
  / props:object_at_props
    { (Function::empty(), props) }

object_after_func -> Properties
  = semisep p:object_at_props
    { p }
  / "}"
    { Properties::empty() }

object_at_props -> Properties
  = p:properties [\n ]* "}"
    { p }
  / "}"
    { Properties::empty() }


proc -> Proc
  = "proc" [ ]+ "{" [\n ]* sb:statementblock [\n ]* "}"
    { Proc(sb) }

statementblock -> StatementBlock
  = "return" [ ]+ pe:procexpression
    { StatementBlock::Return(Box::new(pe)) }


query -> Query
  = "query" arrowsep body:queryexpression
    { Query(Box::new(body)) }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rules [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rules -> Vec<FuncRule>
  = rs:func_rule ** semisep
    { rs }

func_rule -> FuncRule
  = p:pattern arrowsep b:expression
    { FuncRule { pattern: p, body: b } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

properties -> Properties
  = "prop" [ ]+ props:props_from_pattern
    { props }

props_from_pattern -> Properties
  = "(" [\n ]* id:identifier [\n ]* ")" arrowsep b:expression
    {
      Properties::from_varprop(id, b)
    }
  / "." id:identifier arrowsep b:expression props:props_continue
    {
      props.plus_item(id, b)
    }

props_continue -> Properties
  = semisep props:properties
    { props }
  / ""
    { Properties::empty() }


list_expression -> List<Expression>
  = "[" [\n ]* xs:expression ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }

list_queryexpression -> List<QueryExpression>
  = "[" [\n ]* xs:queryexpression ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }

list_procexpression -> List<ProcExpression>
  = "[" [\n ]* xs:procexpression ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }


queryqueryapp -> Box<QueryExpression>
  = "$" target:queryexpression
    { Box::new(target) }

procqueryapp -> Box<ProcExpression>
  = "$" target:procexpression
    { Box::new(target) }

procapp -> Box<ProcExpression>
  = "!" target:procexpression
    { Box::new(target) }


arrowsep -> ()
  = [ ]+ "->" [\n ]+

semisep -> ()
  = ";" [\n ]*
    { () }

commasep -> ()
  = "," [\n ]*
    { () }
