use super::super::ast::{
    DGrammar,
    Expression,
    Function,
    Identifier,
    LeafExpression,
    List,
    Literal,
    Object,
    Pattern,
    PatternItem,
    PGrammar,
    Proc,
    Properties,
    QGrammar,
    Query,
    StatementBlock
};


#[pub]
dgram -> DGrammar
  = e:dexpr { DGrammar::Expr(e) }

qgram -> QGrammar
  = e:qexpr          { QGrammar::Expr(e)      }
  / qa:queryqueryapp { QGrammar::QueryApp(qa) }

pgram -> PGrammar
  = e:pexpr         { PGrammar::Expr(e)      }
  / qa:procqueryapp { PGrammar::QueryApp(qa) }
  / pa:procapp      { PGrammar::ProcApp(pa)  }


dexpr -> Expression<DGrammar>
  = x:leafexpr { Expression::Leaf(x) }
  / l:dlist    { Expression::List(l) }

qexpr -> Expression<QGrammar>
  = x:leafexpr { Expression::Leaf(x) }
  / l:qlist    { Expression::List(l) }

pexpr -> Expression<PGrammar>
  = x:leafexpr { Expression::Leaf(x) }
  / l:plist    { Expression::List(l) }


dlist -> List<DGrammar>
  = "[" [\n ]* xs:dgram ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }

qlist -> List<QGrammar>
  = "[" [\n ]* xs:qgram ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }

plist -> List<PGrammar>
  = "[" [\n ]* xs:pgram ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }


queryqueryapp -> Box<QGrammar>
  = "$" target:qgram
    { Box::new(target) }

procqueryapp -> Box<PGrammar>
  = "$" target:pgram
    { Box::new(target) }

procapp -> Box<PGrammar>
  = "!" target:pgram
    { Box::new(target) }


leafexpr -> LeafExpression
  = i:identifier { LeafExpression::Dereference(i) }
  / l:literal    { LeafExpression::Literal(l)     }
  / o:object     { LeafExpression::Object(o)      }

identifier -> String
  = ! "false"
    ! "func"
    ! "let"
    ! "object"
    ! "proc"
    ! "prop"
    ! "query"
    ! "return"
    ! "true"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }


object -> Object
  = "object" [ ]+ "{" [\n ]* tup:object_at_proc
    {
      let (p, q, f, props) = tup;
      Object { proc_: p, query: q, func: f, props: props }
    }
  / p:proc
    { Object::from_proc(p) }
  / q:query
    { Object::from_query(q) }
  / f:func
    { Object::from_func(f) }

object_at_proc -> (Option<Proc>, Option<Query>, Function, Properties)
  = p:proc [\n ]* tup:object_after_proc
    {
      let (q, f, props) = tup;
      (Some(p), q, f, props)
    }
  / tup:object_at_query
    {
      let (q, f, props) = tup;
      (None, q, f, props)
    }

object_after_proc -> (Option<Query>, Function, Properties)
  = semisep tup:object_at_query
    { tup }
  / "}"
    { (None, Function::empty(), Properties::empty()) }

object_at_query -> (Option<Query>, Function, Properties)
  = q:query [\n ]* tup:object_after_query
    {
      let (f, p) = tup;
      (Some(q), f, p)
    }
  / tup:object_at_func
    {
      let (f, p) = tup;
      (None, f, p)
    }

object_after_query -> (Function, Properties)
  = semisep tup:object_at_func
    { tup }
  / "}"
    { (Function::empty(), Properties::empty()) }

object_at_func -> (Function, Properties)
  = f:func [\n ]* props:object_after_func
    { (f, props) }
  / props:object_at_props
    { (Function::empty(), props) }

object_after_func -> Properties
  = semisep p:object_at_props
    { p }
  / "}"
    { Properties::empty() }

object_at_props -> Properties
  = p:properties [\n ]* "}"
    { p }
  / "}"
    { Properties::empty() }


proc -> Proc
  = "proc" [ ]+ "{" [\n ]* sb:statementblock [\n ]* "}"
    { Proc(sb) }

statementblock -> StatementBlock
  = "return" [ ]+ pe:pgram
    { StatementBlock::Return(Box::new(pe)) }


query -> Query
  = "query" arrowsep body:qgram
    { Query(Box::new(body)) }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rules [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rules -> Vec<PatternItem<DGrammar>>
  = rs:func_rule ** semisep
    { rs }

func_rule -> PatternItem<DGrammar>
  = p:pattern arrowsep b:dgram
    { PatternItem { pattern: p, expr: Box::new(b) } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

properties -> Properties
  = "prop" [ ]+ props:props_from_pattern
    { props }

props_from_pattern -> Properties
  = "(" [\n ]* id:identifier [\n ]* ")" arrowsep b:dgram
    {
      Properties::from_varprop(id, b)
    }
  / "." id:identifier arrowsep b:dgram props:props_continue
    {
      props.plus_item(id, b)
    }

props_continue -> Properties
  = semisep props:properties
    { props }
  / ""
    { Properties::empty() }


arrowsep -> ()
  = [ ]+ "->" [\n ]+

semisep -> ()
  = ";" [\n ]*
    { () }

commasep -> ()
  = "," [\n ]*
    { () }
