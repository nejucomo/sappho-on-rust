use super::super::ast::{
    Expression,
    Function,
    FuncRule,
    Identifier,
    Literal,
    Object,
    Pattern,
    PropBuilder,
    Properties
};


#[pub]
expression -> Expression
  = i:identifier { Expression::Dereference(i) }
  / l:literal    { Expression::Literal(l)     }
  / o:object     { Expression::Object(o)      }

identifier -> String
  = ! "true"
    ! "false"
    ! "func"
    ! "object"
    ! "prop"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }

object -> Object
  = "object" [ ]+ "{" [\n ]* f:func? [\n ]* p:properties? [\n ]* "}"
    {
      Object {
        func: f.unwrap_or_else(|| Function::empty()),
        props: p.unwrap_or_else(|| Properties::empty()),
      }
    }
  / f:func
    { Object::from_func(f) }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rules [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rules -> Vec<FuncRule>
  = rs:func_rule ** semisep
    { rs }

func_rule -> FuncRule
  = p:pattern [ ]+ "->" [\n ]* b:expression
    { FuncRule { pattern: p, body: b } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

properties -> Properties
  = pb:prop_builder
    { pb.as_properties() }

prop_builder -> PropBuilder
  = "prop" [ ]+ props:props_from_pattern
    { props }

props_from_pattern -> PropBuilder
  = "(" [\n ]* id:identifier [\n ]* ")" [ ]+ "->" [\n ]* b:expression
    {
      PropBuilder::new_from_varprop(id, b)
    }
  / "." id:identifier [ ]+ "->" [\n ]* b:expression semisep pb:prop_builder
    {
      pb.add_item(id, b)
    }


semisep -> ()
  = ";" [\n ]*
    { () }
