use super::super::ast::{
    Application,
    Callable,
    Expression,
    Function,
    Identifier,
    Let,
    List,
    Literal,
    Object,
    Pattern,
    PatternItem,
    Proc,
    Properties,
    Query,
    StatementBlock,
    Uncallable
};


#[pub]
expr -> Expression
  = c:callable apps:wsapplication* { Expression::Apps(c, apps) }
  / u:uncallable                   { Expression::Uncallable(u) }

callable -> Callable
  = id:identifier { Callable::Dereference(id) }
  / l:list        { Callable::List(l)         }
  / l:literal     { Callable::Literal(l)      }
  / pe:parensexpr { Callable::Parens(pe)      }
  / pa:procapp    { Callable::ProcApp(pa)     }
  / qa:queryapp   { Callable::QueryApp(qa)    }

wsapplication -> Application
  = [\n ]* a:application { a }

application -> Application
  = "." d:dotapp { d }

dotapp -> Application
  = id:identifier                { Application::Lookup(id)            }
  / "(" [\n ]* x:expr [\n ]* ")" { Application::Dispatch(Box::new(x)) }

uncallable -> Uncallable
  = o:object     { Uncallable::Object(o) }
  / l:let        { Uncallable::Let(l)    }

identifier -> String
  = ! "false"
    ! "func"
    ! "in"
    ! "let"
    ! "object"
    ! "proc"
    ! "prop"
    ! "query"
    ! "return"
    ! "true"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }

parensexpr -> Box<Expression>
  = "(" [\n ]* x:expr [\n ]* ")" { Box::new(x) }


object -> Object
  = "object" [ ]+ "{" [\n ]* tup:object_at_proc
    {
      let (p, q, f, props) = tup;
      Object { proc_: p, query: q, func: f, props: props }
    }
  / p:proc
    { Object::from_proc(p) }
  / q:query
    { Object::from_query(q) }
  / f:func
    { Object::from_func(f) }

object_at_proc -> (Option<Proc>, Option<Query>, Function, Properties)
  = p:proc [\n ]* tup:object_after_proc
    {
      let (q, f, props) = tup;
      (Some(p), q, f, props)
    }
  / tup:object_at_query
    {
      let (q, f, props) = tup;
      (None, q, f, props)
    }

object_after_proc -> (Option<Query>, Function, Properties)
  = semisep tup:object_at_query
    { tup }
  / "}"
    { (None, Function::empty(), Properties::empty()) }

object_at_query -> (Option<Query>, Function, Properties)
  = q:query [\n ]* tup:object_after_query
    {
      let (f, p) = tup;
      (Some(q), f, p)
    }
  / tup:object_at_func
    {
      let (f, p) = tup;
      (None, f, p)
    }

object_after_query -> (Function, Properties)
  = semisep tup:object_at_func
    { tup }
  / "}"
    { (Function::empty(), Properties::empty()) }

object_at_func -> (Function, Properties)
  = f:func [\n ]* props:object_after_func
    { (f, props) }
  / props:object_at_props
    { (Function::empty(), props) }

object_after_func -> Properties
  = semisep p:object_at_props
    { p }
  / "}"
    { Properties::empty() }

object_at_props -> Properties
  = p:properties [\n ]* "}"
    { p }
  / "}"
    { Properties::empty() }


proc -> Proc
  = "proc" [ ]+ "{" [\n ]* sb:statementblock [\n ]* "}"
    { Proc(sb) }

statementblock -> StatementBlock
  = "return" [ ]+ pe:expr
    { StatementBlock::Return(Box::new(pe)) }


query -> Query
  = "query" arrowsep body:expr
    { Query(Box::new(body)) }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rule ** semisep [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rule -> PatternItem
  = p:pattern arrowsep b:expr
    { PatternItem { pattern: p, expr: Box::new(b) } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

properties -> Properties
  = "prop" [ ]+ props:props_from_pattern
    { props }

props_from_pattern -> Properties
  = "(" [\n ]* id:identifier [\n ]* ")" arrowsep b:expr
    {
      Properties::from_varprop(id, b)
    }
  / "." id:identifier arrowsep b:expr props:props_continue
    {
      props.plus_item(id, b)
    }

props_continue -> Properties
  = semisep props:properties
    { props }
  / ""
    { Properties::empty() }


procapp -> Box<Callable>
  = "!" target:callable { Box::new(target) }

queryapp -> Box<Callable>
  = "$" target:callable { Box::new(target) }


list -> List
  = "[" [\n ]* xs:expr ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }


let -> Let
  = "let" [ ]+ xs:let_bindings [\n ]+ "in" [ ]+ x:expr
    { Let { bindings: xs, expr: Box::new(x) } }

let_bindings -> Vec<PatternItem>
  = "{" [\n ]* xs:bindpair ** semisep [\n ]* "}"
    { xs }
  / x:bindpair
    { vec![x] }

bindpair -> PatternItem
  = p:pattern [ ]+ "=" [\n ]+ x:expr
    { PatternItem { pattern: p, expr: Box::new(x) } }




arrowsep -> ()
  = [ ]+ "->" [\n ]+

semisep -> ()
  = ";" [\n ]*
    { () }

commasep -> ()
  = "," [\n ]*
    { () }
