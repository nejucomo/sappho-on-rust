use super::super::ast::{
    Expression,
    Function,
    Identifier,
    LeafExpression,
    Let,
    List,
    Literal,
    Object,
    Pattern,
    PatternItem,
    Proc,
    Properties,
    Query,
    StatementBlock
};


#[pub]
expr -> Expression
  = l:leafexpr  { Expression::Leaf(l)      }
  / pa:procapp  { Expression::ProcApp(pa)  }
  / qa:queryapp { Expression::QueryApp(qa) }
  / l:list      { Expression::List(l)      }
  / l:let       { Expression::Let(l)       }


leafexpr -> LeafExpression
  = i:identifier { LeafExpression::Dereference(i) }
  / l:literal    { LeafExpression::Literal(l)     }
  / o:object     { LeafExpression::Object(o)      }

identifier -> String
  = ! "false"
    ! "func"
    ! "in"
    ! "let"
    ! "object"
    ! "proc"
    ! "prop"
    ! "query"
    ! "return"
    ! "true"
    [A-Za-z][A-Za-z0-9_]* { match_str.to_string() }

literal -> Literal
  = "true"  { Literal::Bool(true)  }
  / "false" { Literal::Bool(false) }


object -> Object
  = "object" [ ]+ "{" [\n ]* tup:object_at_proc
    {
      let (p, q, f, props) = tup;
      Object { proc_: p, query: q, func: f, props: props }
    }
  / p:proc
    { Object::from_proc(p) }
  / q:query
    { Object::from_query(q) }
  / f:func
    { Object::from_func(f) }

object_at_proc -> (Option<Proc>, Option<Query>, Function, Properties)
  = p:proc [\n ]* tup:object_after_proc
    {
      let (q, f, props) = tup;
      (Some(p), q, f, props)
    }
  / tup:object_at_query
    {
      let (q, f, props) = tup;
      (None, q, f, props)
    }

object_after_proc -> (Option<Query>, Function, Properties)
  = semisep tup:object_at_query
    { tup }
  / "}"
    { (None, Function::empty(), Properties::empty()) }

object_at_query -> (Option<Query>, Function, Properties)
  = q:query [\n ]* tup:object_after_query
    {
      let (f, p) = tup;
      (Some(q), f, p)
    }
  / tup:object_at_func
    {
      let (f, p) = tup;
      (None, f, p)
    }

object_after_query -> (Function, Properties)
  = semisep tup:object_at_func
    { tup }
  / "}"
    { (Function::empty(), Properties::empty()) }

object_at_func -> (Function, Properties)
  = f:func [\n ]* props:object_after_func
    { (f, props) }
  / props:object_at_props
    { (Function::empty(), props) }

object_after_func -> Properties
  = semisep p:object_at_props
    { p }
  / "}"
    { Properties::empty() }

object_at_props -> Properties
  = p:properties [\n ]* "}"
    { p }
  / "}"
    { Properties::empty() }


proc -> Proc
  = "proc" [ ]+ "{" [\n ]* sb:statementblock [\n ]* "}"
    { Proc(sb) }

statementblock -> StatementBlock
  = "return" [ ]+ pe:expr
    { StatementBlock::Return(Box::new(pe)) }


query -> Query
  = "query" arrowsep body:expr
    { Query(Box::new(body)) }

func -> Function
  = "func" [ ]+ "{" [\n ]* rs:func_rule ** semisep [\n ]* "}"
    { Function(rs) }
  / "func" [ ]+ r:func_rule
    { Function(vec![r]) }

func_rule -> PatternItem
  = p:pattern arrowsep b:expr
    { PatternItem { pattern: p, expr: Box::new(b) } }

pattern -> Pattern
  = i:identifier
    { Pattern::Bind(i) }

properties -> Properties
  = "prop" [ ]+ props:props_from_pattern
    { props }

props_from_pattern -> Properties
  = "(" [\n ]* id:identifier [\n ]* ")" arrowsep b:expr
    {
      Properties::from_varprop(id, b)
    }
  / "." id:identifier arrowsep b:expr props:props_continue
    {
      props.plus_item(id, b)
    }

props_continue -> Properties
  = semisep props:properties
    { props }
  / ""
    { Properties::empty() }



procapp -> Box<Expression>
  = "!" target:expr
    { Box::new(target) }

queryapp -> Box<Expression>
  = "$" target:expr
    { Box::new(target) }


list -> List
  = "[" [\n ]* xs:expr ** commasep [\n ]* "]"
    { List::from_unboxed_vec(xs) }


let -> Let
  = "let" [ ]+ xs:let_bindings [\n ]+ "in" [ ]+ x:expr
    { Let { bindings: xs, expr: Box::new(x) } }

let_bindings -> Vec<PatternItem>
  = "{" [\n ]* xs:bindpair ** semisep [\n ]* "}"
    { xs }
  / x:bindpair
    { vec![x] }

bindpair -> PatternItem
  = p:pattern [ ]+ "=" [\n ]+ x:expr
    { PatternItem { pattern: p, expr: Box::new(x) } }




arrowsep -> ()
  = [ ]+ "->" [\n ]+

semisep -> ()
  = ";" [\n ]*
    { () }

commasep -> ()
  = "," [\n ]*
    { () }
